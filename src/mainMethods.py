import utils
import apiHandler
import subprocess
import re

class MainMethods():

    util = utils.Utils()
    api = apiHandler.ApiHandler()

    #sends the given code to the LLM and saves the generated specifications into a file
    @classmethod
    def process_file(cls, file, prompt_choice, llm, outputdir, pc_only):
        print("Processing file: " + file)
        if not file.endswith('_b.py'):
            print ("File is not a buggy python file")
            return
        else:
            file_nb = file.replace('_b.py', '.py')
        lines = cls.util.read_file(file)
        lines_nb = cls.util.read_file(file_nb)

        #TODO: Implement parsing the file if necessary
        
        api_result = cls.api.handle_prompt(lines, prompt_choice, llm)
        
        generated_specs = cls.util.get_icontract_specs(api_result, pc_only)
        if generated_specs is None:
            code_with_specs_b = '\n'.join(lines)
            code_with_specs_nb = '\n'.join(lines_nb)
            print('No specifications were generated by the LLM')
        else:
            code_with_specs_b = cls.util.insert_specs(generated_specs, lines)
            code_with_specs_nb = cls.util.insert_specs(generated_specs, lines_nb)
            print('The following specifications were generated by the LLM and inserted into the code:')
            print(code_with_specs_b)

        #TODO: Implement parser for inserting specifications into the code / all 
        # similar programs from buggy / not buggy batch

        outputfile_b = cls.util.create_output_file(file, outputdir, prompt_choice, content = code_with_specs_b)
        outputfile_nb = cls.util.create_output_file(file_nb, outputdir, prompt_choice, content = code_with_specs_nb)   
        
        return outputfile_b, outputfile_nb


    #runs the verifier on the generated code, writes the results to a file and returns the filepath
    @classmethod
    def run_verifier(cls, file, outputdir, verifier, verifier_timeout, prompt_choice):
        print("Running " + verifier + " on file: " + file)
        verification_file = cls.util.create_output_file(file, outputdir, prompt_choice, type = "verification", )
        exit_code = ''
        if verifier == 'frama-c':
            frama_c_cmd = ['frama-c', '-wp', file, '-wp-timeout', str(verifier_timeout), '-wp-prover', 'alt-ergo']
            with open(verification_file, 'w') as f:
                subprocess.run(frama_c_cmd, stdout=f, stderr=subprocess.STDOUT)
        if verifier == 'crosshair':
            crosshair_cmd = ['crosshair', 'check', file, '--report_all', '--report_verbose', '--per_condition_timeout', str(verifier_timeout)]
            result = subprocess.run(crosshair_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            
            ansi_escape = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')
            output = result.stdout
            clean_output = ansi_escape.sub('', output)
            
            with open(verification_file, 'w') as f:
                f.write(clean_output)

            exit_code = result.returncode
        print("Verification results are written to " + verification_file)
        return verification_file, exit_code






