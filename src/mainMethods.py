import utils
import apiHandler
import subprocess
import re

class MainMethods():

    util = utils.Utils()
    api = apiHandler.ApiHandler()

    #sends the given code to the LLM and saves the generated specifications into a file
    @classmethod
    def process_file(cls, file, prompt_choice, llm, outputdir, pc_only):
        print("Processing file: " + file)
        if file.endswith('.c') or file.endswith('.i'):
            language = 'c'
        elif file.endswith('.py'):
            language = 'python'
        lines = cls.util.read_file(file)

        #TODO: Implement parsing the file if necessary
        
        
        api_result = cls.api.handle_prompt(lines, prompt_choice, llm, language)

        if language == 'c':
            generated_specs = cls.util.get_ACSL_specs(api_result)
            if generated_specs is None:
                code_with_specs = '\n'.join(lines)
                print('No specifications were generated by the LLM')
            else:
                code_with_specs = cls.util.insert_specs(generated_specs, lines)
                print('The following specifications were generated by the LLM and inserted into the code:')
                print(code_with_specs)

        if language == 'python':
            generated_specs = cls.util.get_icontract_specs(api_result, pc_only)
            if generated_specs is None:
                code_with_specs = '\n'.join(lines)
                print('No specifications were generated by the LLM')
            else:
                code_with_specs = cls.util.insert_specs(generated_specs, lines)
                print('The following specifications were generated by the LLM and inserted into the code:')
                print(code_with_specs)

        #TODO: Implement parser for inserting specifications into the code / all 
        # similar programs from buggy / not buggy batch

        outputfile = cls.util.create_output_file(file, outputdir, prompt_choice, content = code_with_specs)
        
        return outputfile


    #runs the verifier on the generated code, writes the results to a file and returns the filepath
    @classmethod
    def run_verifier(cls, file, outputdir, verifier, verifier_timeout, prompt_choice):
        print("Running " + verifier + " on file: " + file)
        verification_file = cls.util.create_output_file(file, outputdir, prompt_choice, type = "verification", )
        exit_code = ''
        if verifier == 'frama-c':
            frama_c_cmd = ['frama-c', '-wp', file, '-wp-timeout', str(verifier_timeout), '-wp-prover', 'alt-ergo']
            with open(verification_file, 'w') as f:
                subprocess.run(frama_c_cmd, stdout=f, stderr=subprocess.STDOUT)
        if verifier == 'crosshair':
            crosshair_cmd = ['crosshair', 'check', file, '--report_all', '--report_verbose', '--per_condition_timeout', str(verifier_timeout)]
            result = subprocess.run(crosshair_cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
            
            ansi_escape = re.compile(r'\x1B[@-_][0-?]*[ -/]*[@-~]')
            output = result.stdout
            clean_output = ansi_escape.sub('', output)
            
            with open(verification_file, 'w') as f:
                f.write(clean_output)

            exit_code = result.returncode
        print("Verification results are written to " + verification_file)
        return verification_file, exit_code






